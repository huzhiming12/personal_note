---
title: http和https的区别
date: 2017-05-13 21:11:42
categories: 计算机网络
tags: [http,https]
---

### Http和Https的区别

http协议是未加密的传输，即采用明文的方式发送内容，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就很容易直接读取其中的信息。https就是在http的基础之上加入了SSL协议，SSL用于对http协议传输的数据进行加密。

- https协议需要到ca申请证书，一般需要一定的费用
- http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密协议
- http和HTTPS使用不同的连接方式，用的端口也不同，前者是80端口，后者是443端口
- http的连接是简单无状态的，HTTPS协议是由ssl+http协议构成的可进行加密传输、身份认证的网络协议，比http协议安全。



#### 1.什么是Http

Http中文叫做`超文本传输协议`, 它完成客户端到服务端等一系列运作流程

#### 1.1 与http关系密切的协议: IP, TCP和DNS

#### 负责传输的IP协议

IP协议数据网络层, IP协议的作用是把各类数据包传送给对方. 而要确保确实传送到对方那里, 则需要满足各类条件. 其中两个重要的条件是IP地址和MAC地址.

IP地址指明了节点被分配到的地址, MAC地址是指网卡所指的固定地址. IP地址和MAC地址进行配对, IP地址可以变换, 但是MAC地址基本不会更改.

#### 确保可靠性的TCP协议

TCP位于传输层, 提供可靠的字节流服务

> 字节流服务: 为了方便传输, 将大块数据分割成以报文段为单位的数据包进行管理.

为了确保无误将数据送达目标处, TCP协议采用了三次握手策略.当然除了三次握手策略, 还有很多其他的手段保证通讯的可靠性

#### 负责域名解析的DNS服务

DNS服务是和HTTP协议一样位于应用层的协议. 他提供域名与IP地址之间的解析服务.

因为记住一组纯数字太难了, 而字母加数字才是人类习惯的方式,为了解决这个问题, DNS服务营运而生.

#### 2. HTTP的缺点

- 通信使用明文(不加密), 内容可能会被窃听
- 不验证通信方的身份, 因此有可能遭遇伪装
- 无法证明报文的完整性, 所有有可能已遭篡改

#### 3.HTTP+加密+认证+完整性保护 = HTTPS

HTTPS并非是应用层的一种新协议. 只是HTTP通信接口部分用SLL(Secure Socket Layer)和TLS (Transport Layer Security) 协议替代而已.

通常, HTTP直接和TCP通信, 当使用SSL时, 演变成了先和SSL通信, 再由SSL和TCP通信了, 简而言之, 所谓HTTPS, 其实就是身披SSL协议的这层外壳的HTTP.

在采用SSL后, HTTP就拥有了HTTPS的加密, 证书和完整性的保护这些功能.

SSL是独立于HTTP的协议, 所有不光是HTTP协议, 其他运行在应用层的SMTP(邮件协议)和Telnet等协议均可配合SSL协议使用. 可以说SSL是当今世界上应用最广泛的网络安全技术.

#### 4.SSL是如何加密的

SSL采用一种叫做公开密钥加密(Public-key cryptography)的加密方式.

近代的加密方法中, 加密算法是公开的, 而秘钥是保密的, 通过这种方式得以保持加密方法的安全性.

#### *共享密钥加密*的困境

加密和解密同用一个密钥的方式称为共享密钥加密, 也被叫做对称密钥加密.

共享加密方式加密时必须将密钥也发给对方. 在互联网上转发密钥时, 如果通信被监听那么密钥就会落入攻击者之手, 同事也就失去了加密的意义,

怎么才能安全的转交?

#### 使用两把密钥的*公开密钥加密*

**公开密钥加密**方式很好地解决了**共享密钥加密**的困难

公开密钥加密使用一对非对称的密钥. 一把叫做私有密钥, 另一把叫做公开密钥

使用公开密钥加密方式, 发送密文的一方使用对方的公开密钥进行加密处理, 对方收到被加密的信息后, 在使用自己的私有密钥进行解密. 利用这种方式, 不需要发送用来解密的私有密钥, 也不用担心密钥被攻击者窃听而盗走.

另外, 要想根据密文和公开密钥, 恢复到信息原文是异常困难的, 因为解密过程就是在对离散对数进行求值, 这并非轻而易举就能办到的. 退一步讲, 如果能对一个非常大的整数做到快速地因式分解, 那么密码还是在存在希望的, 但就目前的技术来看是不太现实的.

#### HTTPS采用混合加密机制

HTTPS采用共享秘钥加密 和 公开秘钥加密两者并用的混合加密机制. 若密钥能够实现安全交换, 那么有可能会考虑仅适用公开密钥加密来通信. 但是公开密钥加密和共享密钥加密相比, 其处理速度要慢.

所以应充分利用两者各自优势, 将多种方法组合起来用于通信. 在交换密钥环节适用公开密钥加密方式, 之后的建立通信交换报文阶段则使用共享密钥加密方式.

#### 5.证明公开密钥的正确性的证书

遗憾的是, 公开密钥加密方式还是存在一些问题的, 那就是无法证明公开密钥本身就是货真价实的公开密钥. 比如, 正准备和某台服务器建立公开密钥加密方式下的通信时, 如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥. 或许在公开密钥传输途中, 真正的公开密钥已经被攻击者替换了.

为了解决上述问题, 可以使用有`数字证书认证机构`和`其他相关机关颁发的公开密钥证书`

基本流程为:

- 1.服务器把自己的公开密钥登录至数字证书认证机构
- 2.数字证书认证机构用自己的私有密钥向服务器的公开密钥署数字签名并颁发公钥证书
- 3.客户端拿到服务器的公钥证书后, 使用数字证书认证机构的公开密钥, 向数字证书认证机构验证公钥证书上的数字签名, 以确认服务器的公开密钥的真实性
- 4.使用服务器的公开密钥对报文加密后发送
- 5.服务器用私有密钥对报文解密

#### 6.SSL速度慢吗?

由于HTTPS还需要做服务器,客户端双方加密及解密处理, 因此会消耗CPU和内存等硬件资源, 和HTTP通信相比, SSL通信部分消耗网络资源. 而SSL通信部分, 有因为要对通信进行处理, 所有时间上又延长了.

针对速度慢这样一个问题, 并没有根本性的解决方案, 我们会使用SSL加速器这种(专用服务器)硬件来改善该问题. 相对软件来讲, 能够提高数倍SSL计算速度.

#### 7.为什么不一直使用HTTPS

既然HTTPS那么的可靠安全, 那为何不所有的Web网站不一直使用HTTPS?

其中的一个原因是, 因为与纯文本通信相比, 加密通信会消耗更多的CPU资源以及内存资源, 如果每次通信都加密, 会消耗相当多的资源, 平摊到一台计算机上时, 能够处理的请求数量必定会随之减少.

因此, 如果是非敏感信息则使用HTTP通信, 只有在包括个人信息等敏感数据时, 才利用HTTPS加密通信, 以节省资源. 除此之外, 想要节约购买证书的开销也原因之一.



### Https握手过程

**1. 客户端发起HTTPS请求**

**2. 服务端的配置**

采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。

**3. 传送证书**

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。

**4. 客户端解析证书**

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。

**5. 传送加密信息**

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**6. 服务段解密信息**

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

**7. 传输加密后的信息**

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

**8. 客户端解密信息**

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。

PS: 整个握手过程第三方即使监听到了数据，也束手无策。



### HTTP1.0 与HTTP1.1的区别

- 引入持久化连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。
- 引入管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。
- 增加了Host头域，使多个Server同时共享一个IP地址和端口号
- 增加状态码100，客户端先发送一个只有请求头的数据，测试地址是否可以访问，可以访问随后再发送含有包含body字段的请求

### Http状态码：

- 1xx：指示信息，表示请求已经接收，继续处理
- 2xx：成功，表示请求已经被成功接收、理解、接受
- 3xx：重定向，表示完成请求必须进行更进一步的操作
- 4xx：客户端错误，请求有语法错误或者请求无法实现
- 5xx：服务器端错误，服务器未能实现合法的请求

**常见的状态码：**

* 100：Continue 请求继续，客户端应当继续发送请求的其余部分

- 200：OK——客户端请求成功
- 202：Accepted 请求已经接受，但尚未处理
- 300： Multiple Choices 客户端请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出
- 301：Moved Permanently 客户端请求的文档在其他地方，新的URL在location投中给出，浏览器应该自动访问新的URL
- 400：Bad request——客户端请求有语法错误，不能被服务器解析
- 401：unauthorized——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
- 403：Forbidden——资源不可用，服务器收到请求，但是拒绝提供服务
- 404：Not found——请求资源不存在  如URL输入错误
- 500：Internal Server Error——服务器发生了不可预料的错误
- 502：网关错误
- 503：Server Unavailable——服务器当前不能处理客户端的请求，一段时间后可能恢复正常



#### Http Request请求头常见字段：

- Http请求方式

  ​

- Host：请求的web服务器域名地址

- User-Agent：Http客户端浏览器类型的详细信息

- Accept：指定客户端能够接收的内容类型 text/xml、text/html

- Accept-Language：指定客户端浏览器用来显示返回信息所优先选择的语言

- Accept-Encoding：指定客户端浏览器可以支持服务器返回内容的压缩编码类型，表示客户端浏览器所能支持的返回压缩格式

- Accept-CharSet：浏览器可以接受的字符编码集

- Content-type：此请求提交的内容类型，一般只有post提交时才需要设置该属性

- Connection：表示是否需要持久连接，如果值是keep-Alive或者协议版本是HTTP1.1，就会进行持久连接

- Cookie：http请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器

- Date：请求发送的日期时间

#### Http Response响应头字段：

- Cache-Control：缓存机制,no-cache,private,public,
- Connection:是否要保持持久连接
- Content-Encoding：返回来数据的压缩格式
- Content-Language：相应体的语言
- Content-type：返回资源文件的类型
- Date：服务器发送资源时的服务器时间
- Expiers:告诉客户端在这个时间前可以直接访问缓冲副本，相应过期时间
- Last-Modifed:请求资源的最后修改时间