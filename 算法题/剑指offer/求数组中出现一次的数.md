# 求数组中出现一次的数

#### 数组中只有一个数出现一次，其余各数都出现了两次，求出现一次的数

思路：对数组中的每个数进行异或，最后的结果就是出现一次的数，列如：

1010 ^ 1100 ^ 1010 ^ 1100 ^ 1011  =1011   只有1011出现过一次。

```Java
public class Main
{
	public static void main(String[] args)
	{
		int num []={3,5,6,5,7,6,7};
		int res=0;
		for(int i=0;i<num.length;i++)
			res^=num[i];
		System.out.println(res);
	}
}
```



#### 数组中有两个数出现过了一次，其他的数均出现过两次，求出现过一次的两个数。

思路：根据前面的思路，将所有数进行异或，最终得到的结果肯定是那两个只出现一次的数进行异或的结果。找到结果二进制表示中第一位1的位置index，这表明这两个只出现一次的数这个index位数值肯定不相同。数组中其他的数index为上要么是1要么是0。以次作为划分依据，将数组划分两组，第index位上是1的划分为一组，是0的划分为一组。最后对这两组数据分别做异或，得出的结果就是这两个只出现一次的数。

```Java
public class Main
{
	public static void main(String[] args)
	{
		int num[] = { 5, 3, 6, 5, 7, 6, 7, 8 };
		int res1 = 0, res2 = 0;
		int res = 0;
		for (int i = 0; i < num.length; i++)
			res ^= num[i];
		int index = findFirstByte(res);
		for (int i = 0; i < num.length; i++)
		{
			if (isIndexByteEquals0(num[i], index))
				res1 ^= num[i];
			else
				res2 ^= num[i];
		}
		System.out.println(res1 + " " + res2);
	}

	/*
	 * 查找数字num 二进制表示中 第一个不为0的比特的位置 （从右边开始计数）
	 * 
	 * @return 如 100100 返回3
	 */
	public static int findFirstByte(int num)
	{
		int index = 1;
		while (num != 0)
		{
			int res = num & 1;
			if (res != 0)
				return index;
			index++;
			num = num >> 1;
		}
		return 0;
	}

	/*
	 * 判断num的二进制表示中 第index位是否为 0，(从右边开始计数)
	 * 
	 * 如 100100 index 3
	 */
	public static boolean isIndexByteEquals0(int num, int index)
	{
		while (num != 0 && index > 0)
		{
			num = num >> 1;
			index--;
		}
		int res = num & 1;
		if (res == 0)
			return true;
		return false;
	}
}
```

