# 序列化二叉树

> 题目：请实现两个函数，分别用来序列化和反序列化二叉树



```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    String Serialize(TreeNode root) {
        if(root==null)
            return "";
        LinkedList<TreeNode>queue = new LinkedList<>();
        queue.add(root);
        StringBuffer buffer = new StringBuffer();
        while(!queue.isEmpty())
        {
            TreeNode node = queue.poll();
            if(node==null)
                buffer.append("#,");
            else
            {
                buffer.append(node.val+",");
                if(node.left!=null)
                    queue.add(node.left);
                else
                    queue.add(null);
                
                if(node.right!=null)
                    queue.add(node.right);
                else
                    queue.add(null);
            }
        }
        return buffer.toString();
  	}
    
    TreeNode Deserialize(String str) {
        TreeNode head = null;
       	String[]el = str.split(",");
        if("".equals(str)||el.length==0)
            return head;
        if(!el[0].equals("#"))
        {
            head = new TreeNode(new Integer(el[0]));
        }
        LinkedList<TreeNode>queue = new LinkedList<>();
        queue.add(head);
        
        for(int i=1;i<el.length;i++)
        {
            TreeNode parent = queue.peek();
            if(el[i].equals("#"))
            {
                if(i%2==1)
                    parent.left=null;
                else
                {
                    parent.right=null;
                    queue.poll();
                }
            }else
            {
                int value = new Integer(el[i]);
                TreeNode node = new TreeNode(value);
                if(i%2==1)
                    parent.left=node;
                else
                {
                    parent.right=node;
                    queue.poll();
                }
                queue.add(node);
            }
        }
        return head;
  	}
}
```