# 按之字打印二叉树

题目：

> 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

思路：保证队列元素有序。当访问偶数行时，先访问左孩子，再访问有孩子，并将左右孩子添加在队尾；当访问奇数行时，先访问右孩子，再访问左孩子，并把新元素添加在队列的current位置。

​	 		1                             ——》   【1】 【2，3】

​              2                     3               《——  【2，6，7】【4，5，6，7】

​	4          5          6         7          ——》【5，6，7，8，9】【6，7，8，9，10，11】【7,8,9,10,11,12,13】……

   8    9   10  11   12 13    15    16  《——

​			



```java
import java.util.ArrayList;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        
        ArrayList<ArrayList<Integer> >res = new ArrayList<ArrayList<Integer> >();
        if(pRoot==null)
            return res;
        ArrayList<TreeNode>queue = new ArrayList<>();
        int current =1;
        int next =1;
        int num=0;
        queue.add(pRoot);
        while(!queue.isEmpty())
        {
        	current = next;
            next =0;
            ArrayList<Integer>list = new ArrayList<>();
            while(current>0)
            {
                TreeNode node=null;
                if(num%2==0)
                {	//偶数行时从队列第一个元素进行访问，先左后右，新节点添到队尾
                    node = queue.get(0);
                    queue.remove(0);
                    list.add(node.val);
                    if(node.left!=null){
                    	queue.add(node.left);
                        next++;
                    }
                    if(node.right!=null){
                    	queue.add(node.right);
                        next++;
                    }
                }else{
                  //奇数行时从当前行的最后一个元素开始访问，先右后左，新元素添加在当前行元素的后一位
                	node = queue.get(current-1);
                    queue.remove(current-1);
                    list.add(node.val);   
                    if(node.right!=null){   			//假设当前[2，3]，则先访问3
                    	queue.add(current-1,node.right); //把3的右孩子和左孩子添加在2的后面
                        next++;							//[2,7]->[2,6,7]
                    }									//[5,6,7]->[4,5,6,7]
                    if(node.left!=null){
                    	queue.add(current-1,node.left);
                        next++;
                    }
                }
                current--;
            }
            num++;
            res.add(list);
        }
        return res;
    }

}
```